# c++11 相关整理
#### 右值引用
- 右值引用可以通过&&来绑定右值，所有的具名变量或对象都是左值（比如int i;），而匿名变量则是右值（例如函数返回值），右值引用可以延长函数返回值的生命周期，使其不会在函数结束后被释放，即将亡值，可以利用这个特点为类添加转移构造函数，用来提高效率，比如给一个对象赋函数的返回值时，我们如果使用拷贝构造函数，需要拷贝构造函数两次，一个是函数返回临时对象产生的，一个是赋给当前对象产生的，之后对象会被销毁，也会导致多了一次析构函数（其中还必须使用深拷贝，防止发生指针悬挂，即析构两次的问题），使用右值引用的好处就是，可以把临时对象直接拷贝给当前对象，省去了一次拷贝构造函数，一次析构函数 （没有指针悬挂问题），节省了效率。
- 当发生类型推断时（模板T&& t），如果被左值初始化，那么是左值引用，如果被右值初始化时，是右值引用，如果没有发生类型推断，那么&&是右值引用。
- 右值引用在叠加了正常的引用后会变成左值。
- 可以使用std::move将左值变成右值。即将对象资源所有权从一个对象转到另一个对象，没有内存的拷贝。
- 可以使用std::forward将参数按照实际类型转发，发生类型推断时可能会将我们期望使用右值的地方却使用了左值（本应调用移动构造函数却调用了拷贝构造函数），可以使用forward来避免这个问题。
- 总结：应用于优化拷贝构造函数造成的不必要性能浪费。
#### 常数表达式
- 常数表达式constexpr，可以将确定为常数的变量，函数返回值从运行期执行改到编译期，例如：
```cpp
constexpr int GetFive() {return 5;}
```
使用constexpr修饰的函数需要注意，不能在其定义前使用，不可以返回void，return必须是个常数，以及只能调用其他被contexpr修饰的函数，constexpr 关键字只有当表示式的成员都是 constexpr，才允许编译期常数性的可能。
#### 初始化列表
- 这里主要说一下initializer_list的用法，其提供的操作方式如下：
```cpp
initializer_list<T> lst; 
//默认初始化；T类型元素的空列表
initializer_list<T> lst{a,b,c...};
//lst的元素数量和初始值一样多；lst的元素是对应初始值的副本
lst2(lst)   
lst2=lst  
//拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本元素共享
lst.size()  //列表中的元素数量
lst.begin()  //返回指向lst中首元素的指针
lst.end()   //返回指向lst中尾元素下一位置的指针
```
- 究极无敌方便的一个东西，看完后我知道json库为什么可以直接把不限个数的参数直接传进去了，因为直接使用initializer_list就可以实现了，可以直接在构造函数里遍历复制，注意，initializer_list必须都是常量。同样，我们vector也不用再一个一个的push_back了，可以直接std::vector<int> za = {1,2,3,4};
#### 类型推导(auto)
- 一个非常常用也是特别实用的的东西，尤其可以减少stl里大量的代码量，有明确初始化的参数可以使用auto，decltype 可以再编译器决定变量的类型是什么。
#### 循环
- 可以使用以下循环方式：
```cpp
int a[5] = {1,2,3,4,5};
for(int &i: a){
}
```
#### lambda函数与表达式
- 一个 lambda 函数可以用如下的方式定义:
```cpp
[](int x, int y) { return x + y; }
```
该不具名函数返回值是decltype(x+y)，也可以指定返回类型
```cpp
[](int x, int y)->int{return x+y;}
```
- 在[]中表示该lambda可以使用相同作用域中的哪些东西，这种参数集合在wiki里叫闭包
```cpp
[]  // 沒有定義任何變數。使用未定義變數會導致錯誤。
[x, &y] // x 以傳值方式傳入(預設)，y 以傳參考方式傳入。
[&]   // 任何被使用到的外部變數皆隱式地以參考方式加以引用。
[=]   // 任何被使用到的外部變數皆隱式地以傳值方式加以引用。
[&, x]   // x 顯示地以傳值方式加以引用。其餘變數以參考方式加以引用。
[=, &z]   // z 顯示地以參考方式加以引用。其餘變數以傳值方式加以引用。
std::vector<int> someList;
int total = 0;
std::for_each(someList.begin(), someList.end(), [&total](int x) {
  total += x;
});
std::cout << total;
// copy from wiki
```
- 如果lambda函数被定义于类的成员函数，会被当成友元函数，这样lambda可以使用该类的内部成员，如果lambda设计到了this指针，则必须显式的传入，即[this]，若是[=]火[&]则this指针在lambda中可见。
- 我们可以用auto来存储lambda函数，如果希望将lambda函数以参数的形式传入，该参数的定义必须是模板，  或是用std::function获取lambda的值。我们也可以用如下的方式来获取lambda函数（ps：但是我目前没见过。。。可能是太菜了）
```cpp
std::reference_closure<void()> myLambdaFunc = [this]() { this->SomePrivateMemberFunction(); };
myLambdaFunc();
```
#### 显示虚函数重载（override与final）
- 在派生类里声明带有override修饰的虚函数，如果和父类比较签名方式不同，则会报错。
- 也可以使用final来明确避免类型被继承，或是基类函数被改写。
ps：final应用于函数这里，在effective c++里明确不需要继承的函数一定不要声明为virtual，所以我认为更应该在设计时就考虑清楚，是否需要继承。
#### 空指针（nullptr）
- 在c++11之前NULL就是0(0是因为不允许将void*隐式转换成其他类型，为了是char* c=NULL通过编译，NULL只好为0)，所以可能会导致无法区分语义,以下代码再传null时会有问题
```cpp
int foo(char *)
int foo(int)
```
c++11添加了nullptr解决了这个问题，所以在程序开发中尽量以nullptr代替NULL，需要注意nullptr不可以隐式转换为整数。
#### 强类型枚举
- c++11中引入enum class来表明强类型枚举，enum中，枚举类型可以比较（整数），并且会暴露在当前作用域，因此两个枚举还不可以有相同的名字，所以enum是不安全的，enum class可以解决上面的问题。
#### explicit
- 可以防止构造函数被隐式调用。
#### 正则表达式
- 目前不系统学习，具体用到后会查看
#### 智能指针
- 作简要说明，在effective c++里有过整理，其核心思想史RAII，即对象管理资源，利用c++本身的机制去释放资源，shared_ptr采用的是引用计数的方式，auto_ptr被unique_ptr取代，可以转移所只对象的使用权，weak_ptr和shared_ptr差不多但是不会增加引用计数，可以用来解决shared_ptr的循环引用的问题。


# ps：目前看来常用的就这些，做个小整理给自己留着看，后面可能还会更新，continue。。。。
