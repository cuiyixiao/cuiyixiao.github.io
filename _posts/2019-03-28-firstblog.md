#  阻塞，非阻塞，同步，异步，io模型
### 阻塞，非阻塞，同步，异步
首先贴上陈硕大大的理论
![image.png](https://upload-images.jianshu.io/upload_images/9472400-a9b29d1c760a9a72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 阻塞，进程或者线程需要的数据未就绪时，需要等待。
- 非阻塞，进程或线程需要的数据未就绪时，不需要等待。
- 同步，主动读写数据。
- 异步，io操作完成后，通知，并不主动读写数据。
##### 同步异步和阻塞非阻塞的区别，他们首先描述的对象不同，阻塞非阻塞描述的是进程和线程，同步和异步本身是描述io数据。同步的主动读写io，会导致进程和线程的阻塞，而异步的io则是会等io操作完后通知后才会去读取。
### io模型
- 同步阻塞io，即主动请求数据后必须等待数据准备完毕才继续执行。
- 同步非阻塞io，即如果一次未主动请求到数据，便多次请求数据。
- io多路复用，这个io模型，首先是已经在内核态准备好了数据，之后通知用户去，再将内核数据拷贝（阻塞），拷贝到用户层后进行处理。多路复用即多个描述符复用一个代码执行区。
- 异步io，与io复用模型的区别就是，不需要执行将数据从内核拷贝到用户，而是已经拷贝到用户态后，在通知用户去进行io处理。
- 信号驱动io用的地方不多，不说了。


ps：翻查了很多资料，甚至想了一晚上，io多路复用时同步非阻塞还是异步阻塞，甚至很多人的观点是没有异步阻塞这个概念的，他们认为异步一定是非阻塞的，我想了一晚上，其实只不过是看待时的出发点不同，从线程上的角度（其实就是操作系统调度的角度）来说，确实是同步非阻塞的，包括陈硕大大在知乎上的表里也说是同步，
![image.png](https://upload-images.jianshu.io/upload_images/9472400-765c82e366788a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
但是，从应用者（或者用户态）而言，完全是可以把同步和异步，阻塞，非阻塞分开考虑的，阻塞非阻塞就是是否把进程或者线程阻塞，同步就是主动读数据，异步就是在数据准备好告诉你可以去读了，所以我们在应用者的角度就可以说io多路复用是异步阻塞的（读取数据时阻塞）。

再ps：时至今日，总算把这些基础的东西搞懂，之前一只是概念模模糊糊的，人啊，果然还是要多思考。
